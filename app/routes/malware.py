from app.routes import bp
from flask import current_app as app
from app.db.models.malware import Malware
from flask import json, request
from datetime import datetime
from sqlalchemy import or_, exc


# bp blueprint created in  routes/__init__.py and registered to app in application factory
@bp.get('/api/1/<_hostname_port>/<_path_query>')
@bp.get('/api/1/<_hostname_port>/')
def is_malware(_hostname_port, _path_query=""):
    """
    GET request to check if given hostname:port/path is a malware
    The query sets is_safe = True in the response if given url is a malware
    otherwise is_safe is set to False
    :param _hostname_port: hostname and port for the query url
    :param _path_query: path of the query url
    :return:
        200: json: {"data": {"url": str}, "is_safe": bool}
    """
    # Get the path query passed along with route
    additional_query = request.query_string
    # if any query string is given, it should be added to the url path
    if additional_query:
        _path_query = f"{_path_query}?{additional_query.decode('utf-8')}"

    # Query database for the given url
    fetch = app.session.query(Malware).filter(
        or_(Malware.url == f"{_hostname_port}",
        Malware.url == f"{_hostname_port}/{_path_query}"),
        Malware.dtime.is_(None)
    ).all()

    data = {'url': f"{_hostname_port}/{_path_query}"}
    if len(fetch) != 0:
        # If url is found in db, package the response and send is_safe=False
        response = Malware._set_return_value(data, False)
        return f"{json.dumps(response)}", 200
    else:
        # If url is not found in db, package the response and send is_safe=True
        response = Malware._set_return_value(data, True)
        return f"{json.dumps(response)}", 200


@bp.post('/api/1/add')
def add_malware():
    """
    POST request to add a malware url in the database
    The request should have Content-Type header set to application/json
    The body of request should contain json payload:
    {'url': <url to create>}
    :return:
        200: json: {"data": {"url": str}, "is_safe": bool}
        401: str: ERROR: <exception>
    """
    # get the payload
    data = request.get_json()

    # Query database to see if given url already existed and was soft-deleted
    fetch = app.session.query(Malware).filter(
        Malware.url == f"{data['url']}",
        Malware.dtime.is_not(None)
    ).all()
    response = Malware._set_return_value(data, False)
    if len(fetch) != 0:
        # If url was soft-deleted, set the dtime column to null
        fetch = fetch[0]
        setattr(fetch, 'dtime', None)
    else:
        # If it is a new entry, create the entry
        newdata = Malware(url=data['url'], dtime=None)
        app.session.add(newdata)
    try:
        app.session.commit()

    # If there is any exception during commit, the session should rollback
    except exc.IntegrityError:
        app.session.rollback()
        return f"{json.dumps(response)}", 200
    except Exception as e:
        app.session.rollback()
        return f"ERROR: {e}", 401

    return f"{json.dumps(response)}", 201


@bp.delete('/api/1/delete')
def delete_malware():
    """
    DELETE request to delete the malware url entry from the database
    The request should have Content-Type header set to application/json
    The body of request should contain json payload:
    {'url': <url to create>}
    :return:
        200: json: {"data": {"url": str}, "is_safe": bool}
        401: str: ERROR: <exception>
    """
    data = request.get_json()
    # Query the database to chec if url exists in DB
    fetch = app.session.query(Malware).filter(
        Malware.url == f"{data['url']}",
        Malware.dtime.is_(None)
    ).all()
    if not fetch:
        # If url is not in db, consider it deleted and do nothing
        return json.dumps(Malware._set_return_value(data, True)), 200
    fetch = fetch[0]
    # If it is in db, set the dtime attribute to null to mark it as soft-deleted
    setattr(fetch, 'dtime', fetch.dtime or datetime.now())

    try:
        app.session.commit()
    except Exception as e:
        # If any exception during the commit, session should rollback
        app.session.rollback()
        return f"ERROR: {e}", 401

    # package the response and send is_safe=True
    return json.dumps(Malware._set_return_value(data, True)), 201


@bp.post('/api/1/createmany')
def bulk_create():
    """
    POST request to add multiple urls to malware database at once
    The request should have Content-Type header set to application/json
    The body of request should contain json payload:
    {'malware_list': list(<urls to be added to database>)}
    :return:
        200: json: {"data": [list-of-urls-newly-created]}
        401: str: ERROR: <exception>
    """
    data = request.get_json()
    createlist = list()

    # Query the database for urls that are soft-deleted and need to be re-recreated
    deleted = app.session.query(Malware).filter(
        Malware.url.in_(data['malware_list']),
        Malware.dtime.is_not(None)
    ).all()
    deleted_rows = [x.url for x in deleted]
    deleterows = [i for i in data['malware_list'] if i in deleted_rows]
    for fetch in deleted:
        # For the soft-deleted urls, set the dtime attribute to None to re-create the entry
        setattr(fetch, 'dtime', None)

    # Query the database for urls that already exist and are specified to be created
    existing = app.session.query(Malware).filter(
        Malware.url.in_(data['malware_list']),
        Malware.dtime.is_(None)
    ).all()
    existing = [x.url for x in existing]

    # Exclude the already existing urls and soft-deleted from the list specified for creation
    createrows = [i for i in data['malware_list'] if i not in existing+deleterows]
    try:
        # Only for these filtered urls, create a new entry and append to a list
        for i in createrows:
            createlist.append({'url': i, 'dtime': None})
    except KeyError as e:
        return f"ERROR: {e}", 401

    try:
        # for all the newly created entries, update all at once
        app.session.bulk_insert_mappings(
            Malware, createlist, return_defaults=True)
        app.session.commit()

    # If any exception is raised, session should be rolled back
    except exc.IntegrityError as e:
        app.session.rollback()
        return {'data': createlist}, 200
    except Exception as e:
        app.session.rollback()
        return f"ERROR: {e}", 401
    return {'data': createlist}, 201